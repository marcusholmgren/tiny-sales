from pydantic import BaseModel, ConfigDict, Field, EmailStr
from typing import List, Optional, Any
import datetime

# Base schema for common inventory item attributes
class InventoryItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=255, description="Name of the inventory item")
    quantity: int = Field(default=0, ge=0, description="Current stock quantity of the item")

# Schema for creating a new inventory item
# public_id is generated by the server
# created_at, updated_at are set by the server
# deleted_at is not set on creation
class InventoryItemCreate(InventoryItemBase):
    category_id: Optional[str] = Field(None, description="Public ID of the category to assign to the item")

# Schema for updating an existing inventory item
# All fields are optional for partial updates
class InventoryItemUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255, description="New name of the inventory item")
    quantity: Optional[int] = Field(None, ge=0, description="New stock quantity of the item")
    category_id: Optional[str] = Field(None, description="Public ID of the new category to assign to the item")

# --- Category Schemas ---

class CategoryBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100, description="Name of the category")
    description: Optional[str] = Field(None, max_length=500, description="Optional description for the category")

class CategoryCreate(CategoryBase):
    pass

class CategoryUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100, description="New name of the category")
    description: Optional[str] = Field(None, max_length=500, description="New description for the category")

class CategoryResponse(CategoryBase):
    public_id: str = Field(..., description="Public unique identifier for the category (KSUID)")
    created_at: datetime.datetime = Field(..., description="Timestamp of when the category was created")
    updated_at: datetime.datetime = Field(..., description="Timestamp of when the category was last updated")

    model_config = ConfigDict(
        from_attributes=True,
        protected_namespaces=(),
    )

# Schema for representing an inventory item in API responses
class InventoryItemResponse(InventoryItemBase):
    public_id: str = Field(..., description="Public unique identifier for the item (KSUID)")
    category: Optional[CategoryResponse] = Field(None, description="Category of the inventory item") # No longer a forward reference
    created_at: datetime.datetime = Field(..., description="Timestamp of when the item was created")
    updated_at: datetime.datetime = Field(..., description="Timestamp of when the item was last updated")
    # deleted_at: Optional[datetime.datetime] = Field(None, description="Timestamp of when the item was soft-deleted, if applicable")

    model_config = ConfigDict(
        from_attributes=True,  # Pydantic V2 way to enable ORM mode
        protected_namespaces=(),  # Allow all attributes to be accessed
    )

InventoryItemResponse.model_rebuild() # Needed for forward reference resolution

# Schema for a paginated list of inventory items
class PaginatedInventoryResponse(BaseModel):
    items: list[InventoryItemResponse]
    total: int
    page: int
    size: int
    # pages: int # Can be calculated as ceil(total / size)

    model_config = ConfigDict(
        from_attributes=True,  # Pydantic V2 way to enable ORM mode
        protected_namespaces=(),  # Allow all attributes to be accessed
    )

# --- User Schemas ---

class UserBase(BaseModel):
    username: str = Field(..., min_length=3, max_length=100, description="Username")
    email: EmailStr = Field(..., description="User email address")

class UserCreate(UserBase):
    password: str = Field(..., min_length=8, description="User password")

class UserResponse(UserBase):
    public_id: str = Field(..., description="Public unique identifier for the user (KSUID)")
    role: str = Field(..., description="User role (e.g., customer, admin)")
    is_active: bool = Field(..., description="Whether the user account is active")
    created_at: datetime.datetime = Field(..., description="Timestamp of when the user was created")
    updated_at: datetime.datetime = Field(..., description="Timestamp of when the user was last updated")

    model_config = ConfigDict(
        from_attributes=True,
        protected_namespaces=(),
    )

# --- Auth Schemas ---

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None
    #scopes: List[str] = [] # If using scopes for permissions


# --- Schemas for Order Updates (PATCH requests) ---

class OrderShipRequestSchema(BaseModel):
    tracking_number: Optional[str] = Field(None, description="Tracking number for the shipment")
    shipping_provider: Optional[str] = Field(None, description="Shipping provider for the shipment")

class OrderCancelRequestSchema(BaseModel):
    reason: Optional[str] = Field(None, description="Reason for cancelling the order")


# --- Order Schemas ---

class OrderItemBase(BaseModel):
    product_public_id: str = Field(..., description="Public KSUID of the product (InventoryItem)")
    quantity: int = Field(..., gt=0, description="Quantity of the product")

class OrderItemCreateSchema(OrderItemBase):
    price_at_purchase: float = Field(..., gt=0, description="Price of the product at the time of purchase")

class OrderItemPublicSchema(OrderItemBase):
    public_id: str = Field(..., description="Public KSUID of this order item")
    price_at_purchase: float = Field(..., description="Price of the product at the time of purchase")

    model_config = ConfigDict(
        from_attributes=True,  # Pydantic V2 way to enable ORM mode
        protected_namespaces=(),  # Allow all attributes to be accessed
    )

class OrderEventPublicSchema(BaseModel):
    public_id: str = Field(..., description="Public KSUID of the event")
    event_type: str = Field(..., description="Type of the order event (e.g., order_placed, order_shipped)")
    data: Optional[dict[str, Any]] = Field(None, description="Additional data associated with the event")
    occurred_at: datetime.datetime = Field(..., description="Timestamp of when the event occurred")

    model_config = ConfigDict(
        from_attributes=True,  # Pydantic V2 way to enable ORM mode
        protected_namespaces=(),  # Allow all attributes to be accessed
    )

class OrderBase(BaseModel):
    contact_name: str = Field(..., max_length=255, description="Name of the contact person for the order")
    contact_email: EmailStr = Field(..., description="Email address of the contact person")
    delivery_address: str = Field(..., description="Full delivery address")
    # Add more detailed address fields if they were adopted in models.py:
    # buyer_phone: Optional[str] = Field(None, max_length=50)
    # delivery_address_line1: str
    # delivery_address_line2: Optional[str] = None
    # delivery_city: str
    # delivery_state_province: str
    # delivery_postal_code: str
    # delivery_country: str

class OrderCreateSchema(OrderBase):
    items: List[OrderItemCreateSchema] = Field(..., min_length=1, description="List of items in the order. Must not be empty.")

class OrderPublicSchema(OrderBase):
    public_id: str = Field(..., description="Public KSUID of the order")
    order_id: str = Field(..., description="User-facing order ID (e.g., 20250001)")
    user: Optional[UserResponse] = Field(None, description="User associated with the order")
    status: str = Field(..., description="Current status of the order")
    items: List[OrderItemPublicSchema] = Field(..., description="List of items in the order")
    events: List[OrderEventPublicSchema] = Field(..., description="Chronological list of events for this order")
    created_at: datetime.datetime
    updated_at: datetime.datetime

    model_config = ConfigDict(
        from_attributes=True,  # Pydantic V2 way to enable ORM mode
        protected_namespaces=(),  # Allow all attributes to be accessed
    )

OrderPublicSchema.model_rebuild() # In case UserResponse needs forward ref resolution if it were defined later
