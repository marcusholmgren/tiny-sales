from pydantic import BaseModel, ConfigDict, Field, EmailStr
from typing import List, Optional, Any
import datetime

# Base schema for common inventory item attributes
class InventoryItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=255, description="Name of the inventory item")
    quantity: int = Field(default=0, ge=0, description="Current stock quantity of the item")
    current_price: float = Field(default=0.0, ge=0, description="Current price of the item") # New field

# Schema for creating a new inventory item
# public_id is generated by the server
# created_at, updated_at are set by the server
# deleted_at is not set on creation
class InventoryItemCreate(InventoryItemBase):
    category_id: Optional[str] = Field(None, description="Public ID of the category to assign to the item")

# Schema for updating an existing inventory item
# All fields are optional for partial updates
class InventoryItemUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255, description="New name of the inventory item")
    quantity: Optional[int] = Field(None, ge=0, description="New stock quantity of the item")
    current_price: Optional[float] = Field(None, ge=0, description="New current price of the item") # New field
    category_id: Optional[str] = Field(None, description="Public ID of the new category to assign to the item")

# --- Category Schemas ---

class CategoryBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100, description="Name of the category")
    description: Optional[str] = Field(None, max_length=500, description="Optional description for the category")

class CategoryCreate(CategoryBase):
    pass

class CategoryUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100, description="New name of the category")
    description: Optional[str] = Field(None, max_length=500, description="New description for the category")

class CategoryResponse(CategoryBase):
    public_id: str = Field(..., description="Public unique identifier for the category (KSUID)")
    created_at: datetime.datetime = Field(..., description="Timestamp of when the category was created")
    updated_at: datetime.datetime = Field(..., description="Timestamp of when the category was last updated")

    model_config = ConfigDict(
        from_attributes=True,
        protected_namespaces=(),
    )

# Schema for representing an inventory item in API responses
class InventoryItemResponse(InventoryItemBase):
    public_id: str = Field(..., description="Public unique identifier for the item (KSUID)")
    category: Optional[CategoryResponse] = Field(None, description="Category of the inventory item") # No longer a forward reference
    created_at: datetime.datetime = Field(..., description="Timestamp of when the item was created")
    updated_at: datetime.datetime = Field(..., description="Timestamp of when the item was last updated")
    # deleted_at: Optional[datetime.datetime] = Field(None, description="Timestamp of when the item was soft-deleted, if applicable")

    model_config = ConfigDict(
        from_attributes=True,  # Pydantic V2 way to enable ORM mode
        protected_namespaces=(),  # Allow all attributes to be accessed
    )

InventoryItemResponse.model_rebuild() # Needed for forward reference resolution

# Schema for a paginated list of inventory items
class PaginatedInventoryResponse(BaseModel):
    items: list[InventoryItemResponse]
    total: int
    page: int
    size: int
    # pages: int # Can be calculated as ceil(total / size)

    model_config = ConfigDict(
        from_attributes=True,  # Pydantic V2 way to enable ORM mode
        protected_namespaces=(),  # Allow all attributes to be accessed
    )

# --- User Schemas ---

class UserBase(BaseModel):
    username: str = Field(..., min_length=3, max_length=100, description="Username")
    email: EmailStr = Field(..., description="User email address")

class UserCreate(UserBase):
    password: str = Field(..., min_length=8, description="User password")

class UserResponse(UserBase):
    public_id: str = Field(..., description="Public unique identifier for the user (KSUID)")
    role: str = Field(..., description="User role (e.g., customer, admin)")
    is_active: bool = Field(..., description="Whether the user account is active")
    created_at: datetime.datetime = Field(..., description="Timestamp of when the user was created")
    updated_at: datetime.datetime = Field(..., description="Timestamp of when the user was last updated")

    model_config = ConfigDict(
        from_attributes=True,
        protected_namespaces=(),
    )

# --- Auth Schemas ---

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    sub: Optional[str] = None
    #scopes: List[str] = [] # If using scopes for permissions


# --- Schemas for Order Updates (PATCH requests) ---

class OrderShipRequestSchema(BaseModel):
    tracking_number: Optional[str] = Field(None, description="Tracking number for the shipment")
    shipping_provider: Optional[str] = Field(None, description="Shipping provider for the shipment")

class OrderCancelRequestSchema(BaseModel):
    reason: Optional[str] = Field(None, description="Reason for cancelling the order")


# --- Order Schemas ---

class OrderItemBase(BaseModel):
    product_public_id: str = Field(..., description="Public KSUID of the product (InventoryItem)")
    quantity: int = Field(..., gt=0, description="Quantity of the product")

class OrderItemCreateSchema(OrderItemBase):
    price_at_purchase: float = Field(..., gt=0, description="Price of the product at the time of purchase")

class OrderItemPublicSchema(OrderItemBase):
    public_id: str = Field(..., description="Public KSUID of this order item")
    price_at_purchase: float = Field(..., description="Price of the product at the time of purchase")

    model_config = ConfigDict(
        from_attributes=True,  # Pydantic V2 way to enable ORM mode
        protected_namespaces=(),  # Allow all attributes to be accessed
    )

class OrderEventPublicSchema(BaseModel):
    public_id: str = Field(..., description="Public KSUID of the event")
    event_type: str = Field(..., description="Type of the order event (e.g., order_placed, order_shipped)")
    data: Optional[dict[str, Any]] = Field(None, description="Additional data associated with the event")
    occurred_at: datetime.datetime = Field(..., description="Timestamp of when the event occurred")

    model_config = ConfigDict(
        from_attributes=True,  # Pydantic V2 way to enable ORM mode
        protected_namespaces=(),  # Allow all attributes to be accessed
    )

class OrderBase(BaseModel):
    contact_name: str = Field(..., max_length=255, description="Name of the contact person for the order")
    contact_email: EmailStr = Field(..., description="Email address of the contact person")
    delivery_address: str = Field(..., description="Full delivery address")
    # Add more detailed address fields if they were adopted in models.py:
    # buyer_phone: Optional[str] = Field(None, max_length=50)
    # delivery_address_line1: str
    # delivery_address_line2: Optional[str] = None
    # delivery_city: str
    # delivery_state_province: str
    # delivery_postal_code: str
    # delivery_country: str

class OrderCreateSchema(OrderBase):
    items: List[OrderItemCreateSchema] = Field(..., min_length=1, description="List of items in the order. Must not be empty.")

class OrderPublicSchema(OrderBase):
    public_id: str = Field(..., description="Public KSUID of the order")
    order_id: str = Field(..., description="User-facing order ID (e.g., 20250001)")
    user: Optional[UserResponse] = Field(None, description="User associated with the order")
    status: str = Field(..., description="Current status of the order")
    items: List[OrderItemPublicSchema] = Field(..., description="List of items in the order")
    events: List[OrderEventPublicSchema] = Field(..., description="Chronological list of events for this order")
    created_at: datetime.datetime
    updated_at: datetime.datetime

    model_config = ConfigDict(
        from_attributes=True,  # Pydantic V2 way to enable ORM mode
        protected_namespaces=(),  # Allow all attributes to be accessed
    )

OrderPublicSchema.model_rebuild() # In case UserResponse needs forward ref resolution if it were defined later


# Helper schema for common time period queries
class TimePeriodQuery(BaseModel):
    start_date: Optional[datetime.date] = Field(None, description="Start date for the report period (YYYY-MM-DD)")
    end_date: Optional[datetime.date] = Field(None, description="End date for the report period (YYYY-MM-DD)")

# --- Report Schemas ---

# 1. Total Sales Over Time
class TotalSalesResponse(BaseModel):
    total_revenue: float = Field(..., description="Total revenue generated within the selected time period")
    start_date: Optional[datetime.date] = Field(None, description="Start date of the reporting period")
    end_date: Optional[datetime.date] = Field(None, description="End date of the reporting period")
    item_count: int = Field(..., description="Total number of items sold")
    order_count: int = Field(..., description="Total number of orders included in the report")

# 2. Sales by Product
class ProductSaleInfo(BaseModel):
    product_public_id: str = Field(..., description="Public ID of the product")
    product_name: str = Field(..., description="Name of the product")
    total_quantity_sold: int = Field(..., description="Total quantity of this product sold")
    total_revenue: float = Field(..., description="Total revenue generated by this product")

class SalesByProductResponse(BaseModel):
    products: List[ProductSaleInfo] = Field(..., description="List of products and their sales performance")
    start_date: Optional[datetime.date] = Field(None, description="Start date of the reporting period")
    end_date: Optional[datetime.date] = Field(None, description="End date of the reporting period")

# 3. Sales by Category
class CategorySaleInfo(BaseModel):
    category_public_id: str = Field(..., description="Public ID of the category")
    category_name: str = Field(..., description="Name of the category")
    total_quantity_sold: int = Field(..., description="Total quantity of items sold in this category")
    total_revenue: float = Field(..., description="Total revenue generated by this category")

class SalesByCategoryResponse(BaseModel):
    categories: List[CategorySaleInfo] = Field(..., description="List of categories and their sales performance")
    start_date: Optional[datetime.date] = Field(None, description="Start date of the reporting period")
    end_date: Optional[datetime.date] = Field(None, description="End date of the reporting period")

# 4. Order Status Breakdown
class OrderStatusCount(BaseModel):
    status: str = Field(..., description="Order status")
    count: int = Field(..., description="Number of orders with this status")

class OrderStatusBreakdownResponse(BaseModel):
    status_breakdown: List[OrderStatusCount] = Field(..., description="List of order statuses and their counts")

# 5. Low Stock Items
class LowStockItem(BaseModel):
    product_public_id: str = Field(..., description="Public ID of the product")
    product_name: str = Field(..., description="Name of the product")
    current_quantity: int = Field(..., description="Current stock quantity")
    category_name: Optional[str] = Field(None, description="Name of the product's category")

class LowStockItemsResponse(BaseModel):
    low_stock_items: List[LowStockItem] = Field(..., description="List of items with low stock")
    threshold: int = Field(..., description="The stock threshold used for this report")

# 6. Most Stocked Items
class MostStockedItem(BaseModel):
    product_public_id: str = Field(..., description="Public ID of the product")
    product_name: str = Field(..., description="Name of the product")
    current_quantity: int = Field(..., description="Current stock quantity")
    category_name: Optional[str] = Field(None, description="Name of the product's category")

class MostStockedItemsResponse(BaseModel):
    most_stocked_items: List[MostStockedItem] = Field(..., description="List of items with the highest stock")
    limit: int = Field(..., description="The number of items included in this report")

# 7. Inventory Value
class InventoryValueItem(BaseModel):
    product_public_id: str = Field(..., description="Public ID of the product")
    product_name: str = Field(..., description="Name of the product")
    current_quantity: int = Field(..., description="Current stock quantity")
    current_price: float = Field(..., description="Current price of the product")
    total_value: float = Field(..., description="Total value of this product in stock (quantity * price)")

class InventoryValueResponse(BaseModel):
    total_inventory_value: float = Field(..., description="Total value of the current inventory")
    items_contributing: List[InventoryValueItem] = Field(..., description="Breakdown of value by item")
    item_count: int = Field(..., description="Number of distinct items in inventory")
