import logging
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from typing import Annotated

import schemas
import models
import auth

logger = logging.getLogger(__name__)
router = APIRouter(
    tags=["Authentication"],
)

@router.post("/auth/token", response_model=schemas.Token)
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    """
    OAuth2 compatible token login, get an access token for future requests.
    """
    user = await auth.get_user(username=form_data.username)
    if not user or not auth.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user",
        )

    access_token = auth.create_access_token(
        data={"sub": user.username} # "sub" is a standard JWT claim for subject (username)
    )
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/auth/register", response_model=schemas.UserResponse, status_code=status.HTTP_201_CREATED)
async def register_user(user_in: schemas.UserCreate):
    """
    Register a new user.
    """
    # Check if user already exists by username or email
    existing_user_by_username = await models.User.get_or_none(username=user_in.username)
    if existing_user_by_username:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already registered",
        )

    existing_user_by_email = await models.User.get_or_none(email=user_in.email)
    if existing_user_by_email:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered",
        )

    hashed_password = auth.get_password_hash(user_in.password)

    # Create user instance (public_id is generated by default)
    # Default role is "customer" as per model definition
    user_data = user_in.model_dump(exclude={"password"}) # Exclude plain password
    # logger.info(f"user_data: {user_data}")
    try:
        new_user = await models.User.create(
            **user_data,  # Unpack the user data excluding password
            hashed_password=hashed_password
        )
        # For the response, we need to convert the DB model to the Pydantic response model
        # This typically involves selecting the right fields, especially if using from_orm/model_validate
        # schemas.UserResponse should handle this conversion if model_config.from_attributes = True
        return schemas.UserResponse.model_validate(new_user)
    except Exception as e:
        logger.error("Register user failed. %s",e)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Could not create user.",
        )
