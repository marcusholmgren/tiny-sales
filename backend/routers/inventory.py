import datetime
import logging
from fastapi import APIRouter, HTTPException, status, Query
# Assuming models.py and schemas.py are in the parent directory 'backend'
# and 'backend' is in PYTHONPATH or structured as a package.
# Relative imports for when this router is part of the 'backend' package
from ..models import InventoryItem
from ..schemas import (
    InventoryItemCreate,
    InventoryItemUpdate,
    InventoryItemResponse,
    PaginatedInventoryResponse
)

logger = logging.getLogger(__name__)


router = APIRouter(
    prefix="/inventory",
    tags=["Inventory"],
    responses={404: {"description": "Not found"}},
)

items = []

def to_inventory_response(inventory_item: InventoryItem) -> InventoryItemResponse:
    return InventoryItemResponse(
        name=inventory_item.name,
        quantity=inventory_item.quantity,
        public_id=inventory_item.public_id,
        created_at=inventory_item.created_at,
        updated_at=inventory_item.updated_at
    )

@router.post(
    "/",
    response_model=InventoryItemResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new inventory item"
)
async def create_inventory_item(item_in: InventoryItemCreate):
    """
    Create a new inventory item.
    - **name**: Name of the item (required)
    - **quantity**: Stock quantity (defaults to 0 if not provided in schema, but schema requires it)
    """
    # public_id is generated by the model's default factory (generate_ksuid)
    logger.info("Creating item: %s", item_in)
    try:
        inventory_item = await InventoryItem.create(**item_in.model_dump())
        inventory_item.save()
        # Use from_orm or model_validate if from_tortoise_orm is not available/preferred
        # For Tortoise, from_tortoise_orm is idiomatic
        return to_inventory_response(inventory_item)
    except Exception as e:
        # Generic error for now, can be more specific
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

@router.get(
    "/",
    response_model=PaginatedInventoryResponse,
    summary="List all active inventory items"
)
async def list_inventory_items(
    page: int = Query(1, ge=1, description="Page number"),
    size: int = Query(10, ge=1, le=100, description="Number of items per page")
):
    """
    Retrieve a paginated list of inventory items that have not been soft-deleted.
    """
    offset = (page - 1) * size

    # Query for items and total count separately
    items_query = InventoryItem.filter(deleted_at__isnull=True).order_by('name').offset(offset).limit(size)
    total_count_query = InventoryItem.filter(deleted_at__isnull=True).count()

    items_db = await items_query
    total = await total_count_query

    # Convert DB models to Pydantic response models
    response_items = [to_inventory_response(item) for item in items_db]

    return PaginatedInventoryResponse(
        items=response_items,
        total=total,
        page=page,
        size=size,
    )

@router.get(
    "/{item_public_id}",
    response_model=InventoryItemResponse,
    summary="Get a specific inventory item by its public ID"
)
async def get_inventory_item(item_public_id: str):
    """
    Get a single inventory item by its `public_id`.
    Returns 404 if the item is not found or has been soft-deleted.
    """
    inventory_item = await InventoryItem.get_or_none(public_id=item_public_id, deleted_at__isnull=True)
    if not inventory_item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Inventory item not found or has been deleted"
        )
    return to_inventory_response(inventory_item)

@router.put(
    "/{item_public_id}",
    response_model=InventoryItemResponse,
    summary="Update an inventory item"
)
async def update_inventory_item(item_public_id: str, item_in: InventoryItemUpdate):
    """
    Update an inventory item's name or quantity.
    Only updates fields provided in the request body.
    Returns 404 if the item is not found or has been soft-deleted.
    """
    inventory_item = await InventoryItem.get_or_none(public_id=item_public_id, deleted_at__isnull=True)
    if not inventory_item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Inventory item not found or has been deleted"
        )

    update_data = item_in.model_dump(exclude_unset=True)
    if not update_data:
        # Or return 304 Not Modified, or current representation
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No fields provided for update"
        )

    # Update fields and save
    for key, value in update_data.items():
        setattr(inventory_item, key, value)
    await inventory_item.save()

    return to_inventory_response(inventory_item)

@router.delete(
    "/{item_public_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Soft delete an inventory item"
)
async def delete_inventory_item(item_public_id: str):
    """
    Soft delete an inventory item by setting its `deleted_at` timestamp.
    Returns 404 if the item is not found or has already been soft-deleted.
    """
    inventory_item = await InventoryItem.get_or_none(public_id=item_public_id, deleted_at__isnull=True)
    if not inventory_item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Inventory item not found or already deleted"
        )

    inventory_item.deleted_at = datetime.datetime.now(datetime.timezone.utc) # Use timezone-aware UTC time
    await inventory_item.save()

    # No content to return for 204
    return None
